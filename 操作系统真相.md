### 一些可能正感到迷惑的问题

#### 代码中为什么分为代码段、数据段？

* 首先，cpu是怎么获取指令的。只要给出cpu第一个指令的起始地址，cpu就可以自动获取到下一条指令，直到运行结束。应该是根据cs：ip获取下一条指令的地址。
* 将代码和数据分开的好处：
  * 可以赋予不同的属性。代码段可读，数据段可读和可写。
  * 提高cpu内部缓存的命中率。
  * 节省内存。当一个程序的多个副本运行时，代码段可以复用。
* 我们写的代码，具体是谁给分段并赋予属性的？
  * 编译器负责跳出数据具备的属性，从而根据属性将程序片段分类：只读的代码段、已初始化数据的数据段、具有全局属性但是未初始化的bss段等。
  * 操作系统通过设置GDT，给段配置属性。
  * cpu根据属性来执行行为。



#### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址

* 物理地址：内存的真正地址
* 在实模式下，段基址+段内偏移地址经过段部件的处理，得到的就是物理地址
* 在保护模式下，段基址+段内偏移地址称为线性地址。此时，段基址不再是地址而是一个称为选择子的东西。他的本质是索引，通过这个索引在GDT中找到相应的段信息。（当然，这个要取决于操作系统有没有开启分页，有分页的场景下才是线性地址，否则就同实模式相同。）当然线性地址也称为虚拟地址。

#### 平坦模型

我的理解哈，不一定对。以前cpu是16位的，只能访问64KB的内存，故需要分段访问。但是当前是32位和64位的，完全可以直接访问所有的内存，故出现了平坦模型。

#### 为什么linux下的程序不能在Windows下运行

* 可执行文件格式不同
  * linux下，ELF格式
  * windows下，PE格式
* 操作系统的API系统调用不同。

#### 大端序和小端序

* 小端序
  * 高位在高地址，低位在低地址。
  * 优势：强制转换数据类型时，不需要重新调整字节（原则是增加高位和丢弃高位）。比如：0x12345678转为short变为0x5678
* 大端序
  * 高位在低地址，低位在高地址。
  * 优势：因为地址是从上往下延伸的，低地址->高地址。大端序在内存中的排列就是0x12345678，而小端序是0x78563412.



